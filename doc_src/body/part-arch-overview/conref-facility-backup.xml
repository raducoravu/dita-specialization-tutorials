<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic
  id="topic-id">
  <title>Reuse at the Element Level: The Content Reference Facility</title>
  <shortdesc>DITA provides a powerful use-by-reference facility that allows almost any element to be used by reference from maps or topics as long as specific constraints are mets. This facility is the "content reference facility" or "conref" for short. </shortdesc>
  <prolog>
    <metadata>
      <keywords>
        <indexterm>reuse</indexterm>
        <indexterm>conref</indexterm>
        <indexterm>content reference facility</indexterm>
        <indexterm>use by copy</indexterm>
        <indexterm>use by reference</indexterm>
      </keywords>
    </metadata>
  </prolog>
  <body>
    <p>Conref is represented by two main attributes, <xmlatt>conref</xmlatt> and <xmlatt>conkeyref</xmlatt>, by which one element can link to another element or elements in order to have the referenced elements processed as though they had occurred at the point where the linking element occurs.</p>
    <p>By <term>use by reference</term> I mean using something without copying it. Use by reference is important because it allows a single piece of content to exist in exactly one place and be used in many places.</p>
    <p>The practical benefits of use by reference include minimizing writing effort by not having to maintain multiple copies, minimizing localization costs by allowing the same localized content to be used many times, and enabling the creation of new publications from existing content with a minimum of effort.</p>
    <p>Use by reference is not without costs, however. Once a piece of content is used in two places you have an inherent management challenge in that you must know about all uses and coordinate any changes to the used content with all users. This coordination is either explicit, meaning you have to literally contact the users and talk to them about it, or implicit in the form of business rules or component management features that help ensure that the correct thing (whatever that might be) is done when things change.</p>
    <p>The alternative to use by reference is <term>use by copy</term>. Use by copy means literally copying something and then using the new copy in a new context, e.g. "cut and paste". Use by copy is easy to do because it doesn't require any linking or content management facilities and whatnot, but it has the problem that it results in multiple copies of what is often essentially the same content, copies that often have to be kept in sync. In most cases copies are not tracked, meaning that the knowledge of the original source of the copy is not maintained in a manageable way. As an information management practice use-by-copy is usually the wrong thing to do (although it's not always wrong). Some component management systems do track copy actions, providing a record of what was copied from what an when. As a matter of determining appropriate information use and resuse policies you must clearly distinguish use by copy from use by reference and determine when one or the other is appropriate or required and, when use by copy is allowed or required, determine what the record keeping requirements are for maintaining knowledge of the source of any copies. DITA does not provide any built-in attributes or metadata elements for capturing use-by-copy information.</p>
    <p>Use by reference is a form of hyperlinking and therefore brings with it some of the fundamental challenges of hyperdocument management. A use-by-reference link establishes a dependency that has to be tracked and managed. As the information objects involved go through their normal revision life cycles issues of versioned hyperdocument management are raised. </p>
    <p>For example, if Topic A reflects release 1.0 of a product and re-uses by reference a paragraph from Topic B, what happens when Topic B is updated to reflect release 1.1 of the product? Topic A has to decide which version of the paragraph from Topic B it should now use: The original version? The new version? A third, yet-to-be-created version? If the development of Topic's A and B are coordinated then maybe it's not a problem but if they aren't, then there is a potential issue that has to at least be thought through as part of the general business process analysis activity surrounding the development and management of the documentation system and process that topics A and B participate in. The eventual answer might be "always reflect latest" or it might not be. You might realize you need to start using DITA's conditional processing features to handle the release-specific content or you might need a component management system that provides version-aware addressing facilities.</p>
    <p>The point is that while use-by-reference is powerful and can address difficult business challenges it also introduces complexity that must be considered carefully. In my own experience of more than 20 years working with and building systems for complex documents I have found that use-by-reference is used much less frequently than many people expect when they first move to XML, where "reuse" is a key selling point. I think this is because people find that the management cost and source data complexity often outweighs the benefit, or at least appears to. That is, sometimes it's easier (or appears to be easier) to just make copies and manage the copies than it is to use direct use-by-reference.</p>
    <p>Your mileage will vary of course, and you have to think carefully about local requirements, the tools you have to manage your content, what your authors are capable of or willing to do, and what your business goals and requirements demand. In general, if you can limit use-by-reference to either the topic level (done through maps) or to specific cases where the benefit is clear, such as re-used warnings or steps, then things will be easier. But allowing authors free reign to reuse anything from anywhere is probably a non-starter for most environments.</p>
  </body>
  <topic
    id="subsection_xoc_zyg_hb">
    <title>Use by reference in the world</title>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>external parsed entity</indexterm>
          <indexterm>use by copy</indexterm>
          <indexterm>XInclude</indexterm>
          <indexterm>entity, XML</indexterm>
          <indexterm>XML entity</indexterm>
          <indexterm>SGML</indexterm>
          <indexterm>IBM ID Doc</indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>Before diving into DITA's use-by-reference facilities it's probably useful to talk about all the things DITA doesn't use and why.</p>
      <p>The most obvious one is XML external parsed entities.</p>
      <p>External parsed entities are an XML feature that is a hold over from SGML. An external parsed entity (often informally referred to as "file entities") are fragments of XML documents that are stored as separate resources (e.g., separate files) and referenced from the root XML document (directly or indirectly) using an inline entity reference. The entity's content (the "replacement text") is parsed in the context of the reference, meaning that any markup in the entity must be valid at the point of reference.</p>
      <p>External parsed entities are not use by reference, they are use by copy. This is because entities are essentially string macros, not objects in the computer science sense. The parsing effect of an entity reference is <i>identical</i> to having cut and pasted the content of the entity at the point of reference. By the same token, entity references are not objects in the way that XML elements are, meaning you can't put attributes on them and parsers are not obligated to preserve or report them when parsing a document and providing the parsed results to other processors. Many XML-aware repositories do not preserve entities when storing XML, meaning that knowledge of the original entities is lost when XML is put into the repository. This is true of the MarkLogic product, for example.</p>
      <p>Finally, entities can only be used when you have a DOCTYPE declaration with which to declare them. DOCTYPE declarations are not required by XML generally and are not required by DITA.</p>
      <p>For all these reasons and more, external parsed entities are not a good idea (I have been on record many times as saying "entities are evil" and I stand by that statement). My greatest regret as a member of the XML Working Group is that I actually fought to retain entities in XML when I should have fought to eliminate them.</p>
      <p>External parsed entities provide the <i>illusion</i> of reuse without actually providing it, leading many people astray. DITA correctly and explicitly does not support or encourage the use of external parsed entities. DITA cannot disallow their use but it is certainly not DITA practice to use entities as a matter of course and if you are using them you should stop immediately. The DITA content reference facility is designed, in part, to satisfy the requirements that people thought external parsed entities would satisfy but that they do not.</p>
      <p>Another XML facility is XInclude. XInclude provides a markup-based facility that allows reference to XML content using links. It is better than external parsed entities in that it is markup based (meaning it uses elements rather than something else) but it is not much better than external parsed entities because its mandated behavior is essentially use by copy, not use by reference. This is in part because it is intended to be applied during parsing, rather than after parsing. This means processing applications cannot control the results of XInclude processing. In addition, XInclude rules for ID processing effectively require XML IDs to be unique across all documents that might be involved (because XInclude provides no provision or requirement for ID and pointer rewriting). Finally, XInclude provides no way to constrain where includes might be done nor does it impose any constraints on the content included. This is a problem for authoring because it means you can't control through normal XML means (e.g., content model constraints and markup design) how and where authors do inclusions.</p>
      <p>So XInclude is no good, at least for authoring. Like other W3C standards it might be useful for delivery but that's a pretty rare use.</p>
      <p>Some parsers do support XInclude navitively, such as the Xerces parser, but because it requires using the <xmlelement>xinclude</xmlelement> element in your documents, which DITA explicitly does not include in any form, it is impossible to have a valid and conforming DITA document that uses XInclude.</p>
      <p>In point of fact, DITA's content reference facility predates XML and XInclude by a decade, since it reflects features that were originally designed for the IBM ID Doc document type back in the late 80's and early 90's. But those facilities were designed specifically to overcome the deficiencies in SGML's entity mechanisms, so DITA's solution is still the most complete general solution for element-based, link-based use by reference, probably of any general XML application yet defined.</p>
      <p>If you want to determine whether or not a given content modularity feature is use by reference or use by copy the test is simple: what happens when the same bit of XML content is used twice in the same parent context and that content contains an XML ID? That is, given that the ID must be globally unique in the result following resolution of the uses, what happens?</p>
      <p>If the answer is "the ID attributes and references to them are not modified following use resolution" then you have use by copy, meaning the that result is effectively the same as just having literally copied the content at both points of use (cut and paste). If the answer is "the IDs are made unique in the use context and references to them are modified to be correct following resolution" then you have use by reference.</p>
      <p>This test applies to <i>all</i> forms of identifier and addresses that use them, not just XML IDs. I use XML IDs in the statement of the test because they're obvious. But the requirement applies to any form of address whatsover, since the point is that addresses as authored must continue to be correct in the result of resolving the references, whatever "correct" means. XML IDs are just an obvious way of revealing the problem.</p>
      <p>Because managing IDs and their attendant references requires processing that understands the semantics of the content, not just its syntax, true use by reference facilities cannot be implemented at the syntax level, that is, at the parsing level. That is the primary reason why both external parsed entities and XInclude fail, because they are syntactic, not semantic. By contrast, DITA's conref facility and its map facility are semantic, being done by a DITA-aware processor following parsing of the individual XML documents involved. That means the processors have full knowledge of both the original data content and the semantics of the identifiers and addresses and can therefore do whatever needs to be done to ensure that the resolved result is correct. In the case of element IDs and references to them, DITA has specific rules that ensure that authors can accurately and reliably create links and addresses that are correct as authored and will be correct following all use by reference resolution. This is a significant way in which DITA distinguishes itself from essentially all other XML documentation applications, none of which have an equivalent true use-by-reference facility.</p>
    </body>
  </topic>
  <topic
    id="ss1">
    <title>Basic Conref: Reusing Single Elements</title>
    <shortdesc>The simplest application of conref is a single element using another single element.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>element-to-element</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>A typical use case is re-using notes, cautions, and warnings that are developed and maintained by a specific group, such as the Legal department, where authors should never be writing or modifying them. The general term for notes, cautions, and warnings is <term>admonitions</term>, although this is not a term used in the DITA standard.</p>
      <p>To do a conref you need two things:<ol
        id="ol_vhm_efo_hb">
        <li>A topic that contains the element to be used by reference. Elements to be used by reference must have <xmlatt>id</xmlatt> attributes so that they can be addressed using normal DITA addressing syntax.</li>
        <li>An element of the same <i>or less specialized</i> type that points to the element to be reused.</li>
        </ol></p>
      <p>For this example we have a topic containing a set of admonitions intended to be used by reference:<codeblock>&lt;?xml version="1.0"?>
&lt;!DOCTYPE task PUBLIC "urn:my:local:constrained-task:shell" "task.dtd">
&lt;task id="admonitions">
  &lt;title>Common Admonitions for Tasks&lt;/title>
  &lt;taskbody>
    &lt;steps>
      &lt;step>
        &lt;cmd>&lt;/cmd>
        &lt;info>
          <b>&lt;note id="note-01" type="caution">This is note one.&lt;/note></b>
          <b>&lt;note id="note-02" type="danger">This is note two.&lt;/note></b>
          <b>&lt;note id="note-03" type="warning">This is note three.&lt;/note></b>
        &lt;/info>
      &lt;/step>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Note that this topic is a task topic, not a generic topic. This is because the content reference facility requires that referenced element be the same type or more specialized than the referencing element. Thus, you cannot use elements from less-specialized topics in more-specialized topics. In the case of tasks, which is where you would normally use admonitions, you cannot use elements from less specialized topic types, e.g. <xmlelement>topic</xmlelement>. Thus we need to use a task topic to hold our reusable notes.</p>
      <p>Note further that this example is using the DITA 1.1-style constrained task, not the less-specialized DITA 1.2 general task. This is to ensure that the elements in this task will be compatible with other tasks, both general and constrained.</p>
      <p>Note that this results in a rather odd topic because constrained task requires the <xmlelement>steps</xmlelement> element, which in turn requires <xmlelement>step</xmlelement> which in turn requires <xmlelement>cmd</xmlelement>. So the first place we can put notes is within the <xmlelement>info</xmlelement> element. This is just an unavoidable side effect of the content reference constraints.</p>
      <p>Because this topic only exists to hold elements for reuse it should be referenced in using maps by topicrefs with <xmlatt>process-role</xmlatt> set to "resource-only", e.g.:<codeblock>&lt;map>
  ...
  &lt;topicgroup>
    <b>&lt;topicref 
       href="common/tasks/admonition-set-01.dita"
       processing-role="resource-only"
    /></b>
    ...
  &lt;/topicgroup>
 ...
&lt;/map></codeblock></p>
      <p>If you will have a number of such resource topics, you can make the map simpler by moving the <xmlatt>processing-role</xmlatt> attribute to an ancestor <xmlelement>topicgroup</xmlelement> or <xmlelement>topichead</xmlelement> element:<codeblock>&lt;map>
  ...
  &lt;topicgroup
    <b>processing-role="resource-only"</b>
  >
    &lt;topicref 
      href="common/tasks/admonition-set-01.dita"       
    />
    ...
  &lt;/topicgroup>
 ...
&lt;/map></codeblock></p>
      <p>The attributes of the ancestor element cascade to the descendant elements, so this example sets the effective value of <xmlatt>processing-role</xmlatt> to "resource-only" for all the topicrefs under the topic group.</p>
      <p>To use one of the notes within a real task you simply use a <xmlelement>note</xmlelement> element with the <xmlatt>conref</xmlatt> attribute:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      <b>&lt;note conref="../../common/tasks/admonition-set-01.dita#admonitions/note-01"/></b>
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>The processing effect will normally be that the referenced note is rendered at the point where the <xmlelement>note</xmlelement> with the <xmlatt>conref</xmlatt> attribute occurs.</p>
      <p>I say "normally" because content reference processing is not 100% manditory—you could implement a processor that did something else. That's possible because conref processing is semantic, meaning it happens as part of the processing of the XML data after it has been parsed. It is not a function of the XML parsing itself in the way that entities or XInclude processing is. For example, you might implement a processor that produces a "conref report" that shows what the references are rather than resolving them. The DITA Open Toolkit does conref resolution as part of the generic pre-processing it provides, so later processing normally sees the data following conref resolution. But that's simply an implementation choice—the order in which conref processing is applied is not mandated by the DITA standard.</p>
      <p>Looking at the preceding example note that the <xmlatt>conref</xmlatt> attribute is a direct pointer to the admonition set topic. As discussed in the section on linking and addressing, this establishes a hard dependency between the using task and the admonition set task. In addition, the reference depends on all the files being in the correct relative location.</p>
      <p>A more flexible approach is to replace <xmlatt>conref</xmlatt> with <xmlatt>conkeyref</xmlatt>. We can quickly rework the example to use keys by adding a <xmlatt>keys</xmlatt> attribute to the topicref for the adminition set topic and replacing <xmlatt>conref</xmlatt> with <xmlatt>conkeyref</xmlatt> on the <xmlelement>note</xmlelement> element:<codeblock>&lt;map>
  ...
  &lt;topicgroup>
    &lt;topicref 
       <b>keys="admonition-set-01"</b>
       href="common/tasks/admonition-set-01.dita"
       processing-role="resource-only"
    />
    ...
  &lt;/topicgroup>
 ...
&lt;/map></codeblock></p>
      <p>And in the using topic:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      <b>&lt;note conkeyref="admonition-set-01/note-01"/></b>
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Now the conref is not sensitive to the specific location of the admonition set topic. In addition, different root maps could provide different sets of admonitions for different purposes (say different regulatory environments or different national languages or different product versions).</p>
      <p>Note that the value of the <xmlatt>conkeyref</xmlatt> attribute is the key name, a slash, and the element ID of the target note. This is because the key-defining topicref necessarily addresses a topic, so there is no need in the <xmlatt>conkeyref</xmlatt> to specify the ID of the topic element.</p>
      <p>In this example the ID of the note is just "note-01" but in practice you would probably give specific elements more meaningful IDs that reflect their rhetorical purpose, e.g., "dont-run-with-scissors" for the "Don't run with scissors" danger admonition. </p>
      <p>Because keyref requires that each different topic bound to a given key use the same ID for elements referenced in the context of that key, it makes sense to use meaningful IDs that make it clearer what the purpose of a given element is, whether it's intended for use-by-reference or as the target of cross-references or other navigation links.</p>
    </body>
  </topic>
  <topic
    id="subsection_yha_epc_ib">
    <title>Conref for maps and topics</title>
    <shortdesc>The DITA content reference facility applies to all DITA content, not just topics. This means you can use conref in maps as well as in topics.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>within maps</indexterm></indexterm>
          <indexterm>maps<indexterm>conref  within</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>As far as I can tell it's fairly rare for people to use conref within maps for the simple reason that maps already provide pretty good facilities for constructing compound maps using topicrefs. Nevertheless you can use conref with maps and there may be particular information management challenges that are best met using conref in maps (although I have not encountered them in my own work). Certainly all conforming DITA processors must be prepared to apply conref resolution processing to maps.</p>
      <p>The main caveat for conref within maps is that you cannot reliably use conref to configure or create key definitions, for the simple reason that you cannot resolve any key-based conrefs without first having constructed the key space. If you used key-based conrefs to construct key-defining topicrefs those topicrefs can have no effect on the key space. While a processor could choose to resolve all direct conrefs, then build the key space, and then resolve all key-based conrefs, DITA does not require that processors work in that way. So any map construction scheme that relied on some interaction between conref and key definitions would be dicey at best.</p>
      <p>When doing conref within maps keep in mind that the fragment identifiers for map elements are simply bare <xmlatt>id</xmlatt> values, because each map document is a single ID namespace (as though all <xmlatt>id</xmlatt> attributes had been declared as type ID).</p>
    </body>
  </topic>
  <topic
    id="subsection_rqq_gto_hb">
    <title>Attribute Merging</title>
    <shortdesc>The attributes on the referencing element and referenced elements are merged according to strict rules.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>attribute merging rules</indexterm></indexterm>
          <indexterm>attributes<indexterm>merging through conref</indexterm></indexterm>
          <indexterm>-dita-use-conref-target attribute value</indexterm>
          <indexterm>use-conref-target attribute value<!--<index-see>-dita-use-conref-target attribute value</index-see>--></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>When an element uses another element by reference the attributes of the referencing element and the referenced element are merged such that attributes of the referencing element take precedence over the attributes of the referenced element.</p>
      <p>In the re-used note example the referenced <xmlelement>note</xmlelement> specifies the <xmlatt>type</xmlatt> attribute with the value "caution". Because the referencing element does not also specify <xmlatt>type</xmlatt>, the effective value of <xmlatt>type</xmlatt> following conref resolution will be "caution".</p>
      <p>But if the referencing element specified a different value it would take precedence. For example, this use results in an effective <xmlatt>type</xmlatt> value of "danger":</p>
      <codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition-set-01/note-01"
        <b>type="danger"</b>
      />
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock>
      <p>The default attribute merge behavior can be reversed by using the value "-dita-use-conref-target" for the attribute on the referencing element. This is needed for attributes that are declared as an enumerated set of values with a default. In that case the attribute will always have some value on the referencing element (because of the default) so authors need a way to explicitly indicate that the referenced element's attribute should be used in preference to the referencing element's value.</p>
      <p>For example, in a specialization or constraint module you can set the declaration of the <xmlatt>type</xmlatt> attribute to a subset of the values allowed by the base vocabulary and set a default value of say "note". Having done this, the original example would result in the effective <xmlatt>type</xmlatt> value "note" rather than the value set on the referenced element, because the defaulted attribute on the referencing element would override the value on the referenced element. In this case, authors would need to specify "-dita-use-conref-target" on the referencing element:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition-set-01/note-01"
        <b>type="-dita-use-conref-target"</b>
      />
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>This may seem like something of an edge case but in fact it's probably quite likely as the DITA 1.2 constraint facility makes it easy to tune content models and attribute declarations to match local editorial rules and to make things easier for authors. But having done that, in particular having set defaults on attributes that do not normally have a default value, you must be aware of the implications for conref and train authors appropriately, as the typical author would never figure out why they weren't getting the note type they expected.</p>
    </body>
  </topic>
  <topic
    id="subsection_jwi_wuo_hb">
    <title>Linking to Referencing Elements</title>
    <shortdesc>You link to the result of conref resolution by linking to the referencing element in the content as authored.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>linking<indexterm>conref considerations</indexterm></indexterm>
          <indexterm>conref<indexterm>linking and addressing considerations</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>It is sometimes the case that you need to create a cross-reference to an element that is itself a conref to another element. For example, within a task you might need to create a reference to a step where the step is used by reference.</p>
      <p>In this case, the referencing element must have an <xmlatt>id</xmlatt> attribute and the cross-reference must point to that ID, <i>not</i> the ID of the content reference target.</p>
      <p>For example, given this set of steps:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition/note-01"
        type="-dita-use-conref-target"
      />
      ...
    &lt;/context>
    &lt;steps>
      <b>&lt;step conkeyref="common-steps/remove-access-cover-step"/></b>
      ...
      &lt;step>
        &lt;cmd>...&lt;/cmd>
        &lt;info>
         &lt;p>You must have performed <b>Step 1</b>.         
         &lt;/p>
        &lt;/info>
      &lt;/step>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Where you want to replace the literal text "Step 1" with a cross-reference, you would first put an ID on the referencing element and then refer to that element:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition/note-01"
        type="-dita-use-conref-target"
      />
      ...
    &lt;/context>
    &lt;steps>
      &lt;step <b>id="step-01"</b>
        conkeyref="common-steps/remove-access-cover-step"/>
      ...
      &lt;step>
        &lt;cmd>...&lt;/cmd>
        &lt;info>
         &lt;p>You must have performed 
         <b>&lt;xref href="#task-id/step-01" type="step"/></b>.      
         &lt;/p>
        &lt;/info>
      &lt;/step>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>This reflects the general principle that all addresses in the source data should reflect the data <i>as authored</i>, not as rendered. By pointing to the referencing element the author makes their intent clear and provides enough information to the processor to allow it to do the right thing. By the rules of attribute merging the <xmlatt>id</xmlatt> attribute of the referencing element will be the effective value following conref resolution, so even if conref is implemented as a literal transform the result of that transform will correctly represent the author's intent and the xref will work.</p>
      <p>Or said another way: in the general case, the IDs of referenced elements are only interesting for the purpose of creating conref links, they should have no effect on the content reference result. In the case where you need to create a link to the conref result, you must put an ID on the referencing element. In the case where you don't need to link to the conref result, the effective value of the <xmlatt>id</xmlatt> attribute following conref resolution has no effect on anything because nothing points to it (other than the original referencing element).</p>
    </body>
  </topic>
  <topic
    id="subsection_gsu_mxu_hb">
    <title>Content Reference Constraints</title>
    <shortdesc>The content reference facility imposes some constraints on the elements that can be related together.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>constraints</indexterm></indexterm>
          <indexterm>conref<indexterm>constraint module consistency requirements</indexterm></indexterm>
          <indexterm>constraints<indexterm>on content references</indexterm></indexterm>
          <indexterm>constraint module<indexterm>content reference considerations</indexterm></indexterm>
          <indexterm>general task</indexterm>
          <indexterm>constrained task</indexterm>
          <indexterm>tasks<indexterm>constrained</indexterm></indexterm><indexterm>tasks<indexterm>general</indexterm></indexterm>
          <indexterm><xmlatt>domains</xmlatt> attribute</indexterm>
          <indexterm>attributes<indexterm><xmlatt>domains</xmlatt></indexterm></indexterm>
          <indexterm>domain modules<indexterm>conref considerations</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>The intent of these constraints is to ensure that the resolved result is consistent with the content model rules that apply to the referencing element. In particular, authors should not be able to subvert content model rules by referencing elements that are less constrained.</p>
      <p>The basic rule is that an element can only conref an element of the same type or a <i>more specialized</i> type. You cannot create a conref from a more-specialized element to a less-specialized element. This rule takes advantage of the requirement that specialized elements always be at least as constrained as their base element, which means that specializations can never add things that would be invalid in a more general context following generalization of the specialized elements to less-specialized ancestor types.</p>
      <p>For example, say we create a new "admonition" domain that creates distinct element types for the note types "caution", "warning", and "danger", resulting in elements like:<codeblock>&lt;warning class="+ topic/note admon-d/warning ">This is a warning&lt;/warning>
&lt;danger class="+ topic/note admon-d/danger ">This is a danger&lt;/danger> </codeblock></p>
      <p>Where <xmlelement>warning</xmlelement> sets the value of the <xmlatt>type</xmlatt> attribute to "warning" and <xmlelement>danger</xmlelement> sets <xmlatt>type</xmlatt> to "danger" in the DTD.</p>
      <p>We then use this domain to create a set of re-usable admonitions, as in the original re-used note example above, but using our specializations of <xmlelement>note</xmlelement>.</p>
      <p>From a topic that needs to use one these admonitions by reference we can use either <xmlelement>note</xmlelement> or the specialization as the referencing element:<codeblock>&lt;task id="task-id">
  ...
  &lt;context>
    &lt;<b>note</b> conkeyref="admonition-set-02/warning-01"/>
    &lt;<b>warning</b> conkeyref="admonition-set-02/warning-02"/>
  &lt;/context>
  ...
&lt;/task></codeblock></p>
      <p>Both forms of conref are valid in this case because in the case of <xmlelement>note</xmlelement> as the referencing element, the referenced element is a more-specialized note (<xmlelement>warning</xmlelement>). In the case of <xmlelement>warning</xmlelement> as the referencing element, the referenced element is the same element type.</p>
      <p>However, it would not be valid to use <xmlelement>warning</xmlelement> to conref to one of the <xmlelement>note</xmlelement> elements from the admonition set one topic, because the <xmlelement>note</xmlelement> elements in that topic are <i>less</i> specialized than <xmlelement>warning</xmlelement>.</p>
      <p>The reasoning behind this rule is that, because specialized elements must always be at least as constrained as their base, specialized elements can never allow things that aren't allowed by less-specialized versions of the element, but less-specialized elements may allow things that are not allowed by more-specialized versions. In order to ensure that the resolved result does not violate any content model rules of the referencing context, conref of less-specialized elements cannot be allowed.</p>
      <p>In addition to this basic rule for less and more specialized elements, there is an additional rule involving the use of constraint modules: the constraints used in the referencing document must be consistent with the constraints used in the referenced document such that the referenced document is not less constrained than the referencing document.</p>
      <p>This is why you cannot conref from a DITA 1.1-style constrained task to elements in a DITA 1.2 general task: the constrained task in DITA 1.2 uses a constraint module that makes it match the DITA 1.1 task model. Because general task does not use this constraint module, it is less constrained. You can, however, use elements from constrained tasks by reference from unconstrained tasks because in that case the referenced elements are more constrained than the referencing elements.</p>
      <p>For example, you could define a constraint module that removes <xmlelement>object</xmlelement> from the content model for <xmlelement>note</xmlelement>, for whatever reason. If that constraint module is integrated with the task shell for the referencing task but not with the task shell for the admonition set task, then it would not be possible to conref from the referencing task to the admonition set task because the referencing task is more constrained than the referenced task. On the other hand, if the admonition set topic used the constraint module and the referencing task did not, the conref would be fine because the referenced topic is more constrained than the referencing topic.</p>
      <p>Processors determine whether or not two DITA documents have consistent constraints by examing the value of the <xmlatt>domains</xmlatt> attribute on the root elements of the documents involved. The <xmlatt>domains</xmlatt> attribute lists all domain and constraint modules used by the document (and should list all structural modules used, but that is not required in DITA 1.2). By comparing their <xmlatt>domains</xmlatt> values a processor can determine if two documents use the same set of domains and constraints or, in the case where one domain is a specialization of another domain, that the referenced document's domains are all the same as or more specialized than the referencing element's.</p>
      <p>Note that for constraint modules, the referenced document must use the same or more constraints. For domain modules, the referenced document must use the same or fewer domains. This is because constraint modules limit what can be used, but domain modules extend what can be used, so fewer domain modules means more constrained (fewer things allowed).</p>
      <p>Note also that processors are not doing direct analysis of content models on an element-type basis, they are only comparing the set of vocabulary and constraint modules used by the two documents involved in the conref relationship. This means that a processor might disallow a conref because the domain and constraint modules are not consistent even though a human can inspect the content models of the elements involved and determine that the content models of those particular elements are consistent.</p>
      <p>In practice you should be working in an environment where all the topic and map types are managed as a whole and therefore the definer of the document type shells can ensure that all the topic and map types use either exactly the same domains and constraints as appropriate (e.g., all specializations of <xmlelement>task</xmlelement> use the same constraints and domains) or that map and topic types intended to hold reusable elements are as or more constrained than any map or topic type that would use those elements. In the second case, this might mean creation of topic or map types that use the intersection of all domains that are used by the different topic or map types that would use those elements.</p>
      <p>Finally, note that many DITA-aware tools do not actually check or validate conref constraints, even though they should. This puts the burden on the people setting up DITA environments and sets of map and topic types and document type shells to both ensure that the conref constraints will not violated by references that authors will or are likely to create and to train authors to understand that there are constraints and what they are, so that authors are less likely (or simply unable) to create content references that will be rejected by tools that do validate conref constraints.</p>
    </body>
  </topic>
  <topic
    id="ss2">
    <title>Reusing a Range of Elements: conref range</title>
    <shortdesc>You can reuse sequences of elements using the conref range facility.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref range</indexterm>
          <indexterm>conref<indexterm>using sequences of elements</indexterm></indexterm>
          <indexterm>range, conref</indexterm>
          <indexterm><xmlatt>conrefend</xmlatt> attribute</indexterm>
          <indexterm>attributes<indexterm><xmlatt>conrefend</xmlatt></indexterm></indexterm>
          <indexterm>constraints<indexterm>on conref range references</indexterm></indexterm>
          <indexterm>attributes<indexterm>merging through conref range</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>There are times when you want to re-use a sequence of elements as a unit, for example, a set of steps. You could, of course, create one conref for each element in the sequence but that's tedious and hard to maintain. DITA 1.2 adds the "conref range" feature, which allows you to use a single element to reuse a sequence of elements. In fact, it's not just a sequence of elements but a sequence of sibling nodes, meaning that the conref result includes any text or processing instruction nodes that occur between the start element and the end element, not just element nodes.</p>
      <p>You specify a range conref by pointing to the start of the range using <xmlatt>conref</xmlatt> or <xmlatt>conkeyref</xmlatt> as for a single-element conref and then using <xmlatt>conrefend</xmlatt> to specify the ID of the last element in the range. </p>
      <p>For example, given this topic containing steps to be used by reference, bound to the key "step-set-01":<codeblock>&lt;task id="reusable-steps">
  &lt;title>Reusable Steps&lt;/title>
  &lt;taskbody>
    &lt;steps>
      &lt;step id="step-01">...&lt;/step>
      &lt;step id="step-02">...&lt;/step>
      &lt;step id="step-03">...&lt;/step>
      &lt;step id="step-04">...&lt;/step>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>You could pull in two or more of the steps like so:<codeblock>&lt;task id="task-id">
  ...
  &lt;steps>
    <b>&lt;step conkeyref="step-set-01/step-01"
          conrefend="dontcare.dita#topicid/step-03"
    /></b>
  &lt;/steps>
  ...
&lt;/task></codeblock></p>
      <p>Note that the value of <xmlatt>conrefend</xmlatt> is a direct DITA URI reference complete with fragment identifier. However, the only part of that reference that is actually relevant is the ID component, "step-03" in this example.</p>
      <p>That's because when you use <xmlatt>conkeyref</xmlatt> the key reference determines the topic context for the conref end, meaning that everything except the element ID part of the <xmlatt>conrefend</xmlatt> value must be ignored.</p>
      <p>If you are using <xmlatt>conref</xmlatt> and <xmlatt>conrefend</xmlatt> then the address used in <xmlatt>conrefend</xmlatt> must point to the same topic as the address in <xmlatt>conref</xmlatt>. But you should never, never, never, never use <xmlatt>conref</xmlatt> in preference to key-based addressing, so the issue should never come up.</p>
      <p>Of course you cannot just refer to random sequences of elements willy-nilly. You must observe some constraints:<ol
        id="ol_lwv_bhv_hb">
        <li>The first and last elements of the range must have the same parent element.</li>
        <li>The parent element of the referencing element must be the same as or more specialized than the parent of the referenced elements.</li>
        <li>The first and last elements in the range must be of the same or more specialized types than the referencing element.</li>
        </ol></p>
      <p>This means you can pull sequences of list items into lists or steps into steps or paragraphs into a topic body. But, for example, you couldn't use conref range to pull multiple notes from the admonition-set-01 document into a <xmlelement>context</xmlelement> element because the parent element of the <xmlelement>note</xmlelement> elements is <xmlelement>info</xmlelement> in that example.</p>
      <p>While the start and end elements of a range must be of the same or more specialized types, that is not true of intermediate elements, so you could have a range of steps that includes one or more <xmlelement>stepsection</xmlelement> elements between the first and last <xmlelement>step</xmlelement> elements. Or you could use a <xmlelement>p</xmlelement> element to point to a range of elements bracketed by <xmlelement>p</xmlelement> but including anything valid in the parent element type.</p>
      <p>The rules for attribute merging are a bit more complicated in that attributes specified on the referencing element get merged to all the sibling elements in the referenced range (but not to descendants of the elements in the range). The values of <xmlatt>id</xmlatt> attributes on elements other than the first and last member of the range are preserved, meaning that references from one member of the range to another member of the range should work following reference resolution. In a conref processor that creates a literal result document it is up to the processor to rewrite IDs and references in the referenced elements to ensure that all addresses in the resolved result are correct and unambiguous.</p>
    </body>
  </topic>
  <topic
    id="ss3">
    <title>Unilateral Change: Conref Push (<xmlatt>conaction</xmlatt> attribute)</title>
    <shortdesc>The conref push feature lets you replace elements in or impose additional elements into topics or maps, allowing you to change or extend content you can't or shouldn't modify directly.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>attributes<indexterm><xmlatt>conaction</xmlatt></indexterm></indexterm>
          <indexterm><xmlatt>conaction</xmlatt> attribute</indexterm>
          <indexterm>conref<indexterm>push</indexterm></indexterm>
          <indexterm>push conref</indexterm>
          <indexterm>unilateral change to content using conref push</indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>Because DITA enables true blind interchange it means you might be in a situation where you get content from a third party, such as a publisher or the supplier of subcomponents of the product you're documenting or simply another business unit within your enterprise. You can easily integrate this content into your publications using maps. What you can't, or shouldn't, do is modify the content after you get it.</p>
      <p>However, there is often a need to change or extend the third-party content to reflect your use of it, perhaps to add commentary to regulations or add use-context-specific or product-specific information to otherwise generic topics.</p>
      <p>This requirement is addressed by the DITA 1.2 conref push facility, expressed through the <xmlatt>conaction</xmlatt> attribute.</p>
      <p>Conref push lets you point into a map or a topic and link elements before or after an element in order to make the new elements effectively part of the topic or map linked to. You can also replace elements in the referenced context with pushed elements.</p>
      <p>For example, given a generic task for a common subcomponent of a larger product, you could use conref push to add product-specific steps to the generic task or to replace generic steps or context information with product-specific information.</p>
      <p>You create a push conref by creating a topic that holds the content to be pushed and points at the topic to be pushed to. Within the topic to be pushed to, the elements that serve as the push targets must have IDs, just as for any other use of conref. You then include both topics in your map. Normally you would include the pushing topic with a processing role of "resource-only" since it's only purpose is to push content to another topic that is, presumably, in the main navigation flow of the publication.</p>
      <p>The possible actions for conref push are "pushreplace", "pushbefore", and "pushafter" and they mean exactly what their names suggest.</p>
      <p>The "pushreplace" action completely replaces the referenced element with the referencing element.</p>
      <p>The "pushbefore" and "pushafter" actions put the referencing element before or after the referenced element, before for "pushbefore" and after for "pushafter". For pushes, the same constraints as for conref range hold: the pushed element must be the same type or more specialized than the referenced element and both elements must have the same type of parent or the pushed element's parent must be more specialized than the referenced element's parent. This helps ensure that the result of the push is schema valid.</p>
      <p>When you use a <xmlatt>conaction</xmlatt> of "pushbefore" or "pushafter" you must also create an instance of the same element type as the pushing element that uses a <xmlatt>conaction</xmlatt> value of "mark". Effectively the "marker" element serves as a local proxy for the target element you're pushing relative to and helps ensure that the resolved result will be schema valid.  The marker element points to the same element as the pushing element.</p>
      <p>Because the "marker" element serves as a proxy for the target of the push, it goes in the same position relative to the pushing element as the pushed element will be relative to the referenced element. Thus, for an action of "push after", the marker element goes before the pushing element and for an action of "push before" the marker element goes after the pushing element. Both cases are shown in the example below.</p>
      <p>For example, given this task topic, bound to the key "generic-task-01":<codeblock>&lt;task id="generic-task">
  &lt;title>&lt;ph id="title-text">Some Generic Task&lt;/ph>&lt;/title>
  &lt;taskbody>
    &lt;context id="context">
     &lt;p>This is the generic context.&lt;/p>
    &lt;/context>
    &lt;steps>
      &lt;step id="step-first">
        &lt;cmd>The first thing you do.&lt;/cmd>
      &lt;/step>
      ...
      &lt;step id="step-last">
        &lt;cmd>The last thing you do.&lt;/cmd>
      &lt;/step>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>You could use conref push to both replace the <xmlelement>context</xmlelement> element with a product-specific one and insert new steps before or after the first or last steps. You do this by creating a separate task topic:<codeblock>&lt;task id="push-to-generic">
  &lt;title>Conref push task&lt;/title>
  &lt;taskbody>
    <b>&lt;context
      conkeyref="generic-task-01/context"
      conaction="pushreplace"
    ></b>
     &lt;p>This is product-specific context.&lt;/p>
    <b>&lt;/context></b>
    &lt;steps>
      <b>&lt;step
        conkeyref="generic-task-01/step-first"
        conaction="pushbefore"
      ></b>
        &lt;cmd>Do this before you do anything else.&lt;/cmd>
      <b>&lt;/step></b>
      &lt;step
        conkeyref="generic-task-01/step-first"
        conaction="mark">
        &lt;!-- Required marker element for the push-before action.
            
             Goes after the pushing element (same relative position
             as the referenced element).
          -->
       &lt;cmd/>&lt;/step>
      &lt;step
        conkeyref="generic-task-01/step-last"
        conaction="mark">
        &lt;!-- Required marker element for the push-after action 
            
             Goes before the pushing element (same relative position
             as the referenced element).
          -->
        &lt;cmd/>&lt;/step>
      <b>&lt;step
        conkeyref="generic-task-01/step-last"
        concation="pushafter"
      ></b>
        &lt;cmd>Do this after you do everything else.&lt;/cmd>
      <b>&lt;/step></b>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>In this topic note the following key bits:<ul
        id="ul_vqy_fpd_ib">
        <li>The required marker elements for the two conref pushes.</li>
        <li>The marker <xmlelement>step</xmlelement> elements have empty <xmlelement>cmd</xmlelement> elements. This is because the content model for <xmlelement>step</xmlelement> requires <xmlelement>cmd</xmlelement> so it has to be there in order for the document to be schema valid even though the element's content is ignored.</li>
        <li>The order of the marker elements: after the pushing element for push before and before the pushing element for push after.</li>
        </ul></p>
      <p>You would then include both topics in a map like so:<codeblock>&lt;map>
 &lt;topicgroup 
   processing-role="resource-only">
   <b>&lt;topicref 
      href="prod-specific/tasks/push-to-generic-task-01.dita"
      
   ></b>
 &lt;/topicroup>
 ...
 &lt;topichead>
   &lt;topicmeta>
     &lt;navtitle>Product-Specific Manual&lt;/navtitle>
   &lt;/topicmeta>
   ...
   <b>&lt;topicref
     keys="generic-task-01"
     href="common/tasks/generic-task-01.dita"
   /></b>
   ...
 &lt;/topichead>
&lt;/map></codeblock></p>
      <p>The first topicref in the map pulls in the pushing task as a resource. This makes the topic available to the processor but doesn't include it in the main navigation hierarchy of the map. Note that the <xmlatt>processing-role</xmlatt> attribute on the containing <xmlelement>topicgroup</xmlelement> makes all the topicrefs within the topicgroup into resource-only topicrefs, which is what we want for the reference to the pushing topic.</p>
      <p>The second topicref pulls in the generic task with the (default) processing role of "normal", which includes it in the main navigation hierarchy. The topicref also binds the key "generic-task-01" to the topic as used in this context.</p>
      <p>The processing result is that the rendered result of processing generic-task-01.dita at that location in the map will reflect the replacement of the original <xmlelement>context</xmlelement> element with the one from the pushing task, the insertion of a new step before step "step-first" and a new step after step "step-last", e.g., equivalent to this task topic:<codeblock>&lt;task id="generic-task">
  &lt;title>&lt;ph id="title-text">Some Generic Task&lt;/ph>&lt;/title>
  &lt;taskbody>
    &lt;context id="context"
    >
     &lt;p>This is product-specific context.&lt;/p>
    &lt;/context>
    &lt;steps>
      &lt;step
      >
        &lt;cmd>Do this before you do anything else.&lt;/cmd>
      &lt;/step>
      &lt;step id="step-first">
        &lt;cmd>The first thing you do.&lt;/cmd>
      &lt;/step>
      ...
      &lt;step id="step-last">
        &lt;cmd>The last thing you do.&lt;/cmd>
      &lt;/step>
      &lt;step
      >
        &lt;cmd>Do this after you do everything else.&lt;/cmd>
      &lt;/step>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Finally, note that in DITA 1.2 conref push can only be used for single elements, not for ranges. This restriction is to avoid cases where the resolved result would not be schema valid.</p>
      <p>An important but non-obvious aspect of conref push is that, when you use key-based addressing, you can push different content onto the same topic when used in different places in the map. The technique is simple: you put distinct keys on each use of the topic you want to push to and then use <xmlatt>conkeyref</xmlatt> to specify the appropriate key for each different thing to be pushed.</p>
      <p>For example, in a manual that covered serveral product models, you could have a generic task that is included multiple times, one for each different product, and given distinct keys. You could then push different product-specific content onto those different uses.</p>
      <p>For example, say that the generic topic from the preceding examples is used twice in the map:<codeblock>&lt;map>
 &lt;topicgroup 
   processing-role="resource-only">
   &lt;topicref 
      href="prod-specific/tasks/push-to-generic-task-01.dita"
      
   >
 &lt;/topicroup>
 ...
 &lt;topichead>
   &lt;topicmeta>
     &lt;navtitle>Product-Specific Manual&lt;/navtitle>
   &lt;/topicmeta>
   ...
   <b>&lt;topicref
     keys="generic-task-01-prod-A"
     href="common/tasks/generic-task-01.dita"
   /></b>
   <b>&lt;topicref
     keys="generic-task-01-prod-B"
     href="common/tasks/generic-task-01.dita"
   /></b>
   ...
 &lt;/topichead>
&lt;/map></codeblock></p>
      <p>Now the same topic, generic-task-01.dita, is used twice, with each use getting a distinct key.</p>
      <p>From a pushing topic you could now set the title text to be product specific:<codeblock>&lt;task id="pushing-task">
   &lt;title>
     <b>&lt;ph conkeyref="generic-task-01-prod-A"
         conaction="pushreplace"
     >Product A Toner Replacement Procedure&lt;/ph></b>
     <b>&lt;ph conkeyref="generic-task-01-prod-B"
         conaction="pushreplace"
     >Product B Toner Replacement Procedure&lt;/ph></b>
   &lt;/title>
&lt;/task></codeblock></p>
      <p>Here the pushing topic contains two pushes, one to the topic as used with the key "generic-task-01-prod-A" and one to the topic as used with the key "generic-task-01-prod-B". The processing result should be that two distinct copies of the generic task are created in the output, one for each use and reflecting the different pushes.</p>
      <p>Note that in this example the title text is managed through a <xmlelement>ph</xmlelement> element within the <xmlelement>title</xmlelement> element. This is because the content model for <xmlelement>topic</xmlelement> allows exactly one <xmlelement>title</xmlelement> element, so in order to be able to use a single pushing topic to push multiple title text values, I had to move the title text into the <xmlelement>ph</xmlelement> element, which can of course occur multiple titles within <xmlelement>title</xmlelement>.</p>
    </body>
  </topic>
  <topic
    id="ss4">
    <title>Content Reference Data Management Strategies</title>
    <shortdesc>Management of conref references requires following a few general practices.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>management strategies for</indexterm></indexterm>
          <indexterm>data management strategies<indexterm>for conref</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>To recap the general practices for making conref manageable:<ul
        id="ul_yyu_fqj_ib">
        <li>Use keys and <xmlatt>conkeyref</xmlatt> to avoid hard topic-to-topic dependencies and make your content more flexible.</li>
        <li>Use meaningful and consistent IDs on elements that are intended or may be the targets of conref links.</li>
        <li>Establish clear business rules and policies for what must be used by reference, what may be used by reference, and what should not be used by reference. In general, do not allow arbitrary use by reference.</li>
        <li>Organize content to be used by reference into specific areas on the file system or within your content repository.</li>
        <li>Use domain and constraint modules consistently to ensure that all allowed or appropriate referencing and referenced documents satisfy the content reference constraint rules for consistency of vocabulary and constraint use.</li>
        </ul></p>
    </body>
  </topic>
</topic>
